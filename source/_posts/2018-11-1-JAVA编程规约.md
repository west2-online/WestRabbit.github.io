---
title: Java开发规约
date: 2018-11-01 13:10:53
author: CoderQiang
tags:
	- Java
	- 15级
---

<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">消防局最主要的工作不是灭火，而是为了不发生火灾建立很多规范。</span></span><span data-type="background" style="background-color:rgb(255, 255, 255)"><span data-type="color" style="color:#F5222D">前车之鉴，后车之师</span></span><span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，本规约力求知其然，更知其不然，定位为轻松的双向约定，而非冰冷的法律文书，以开发的视角，结合正反例和历史故障数据分析，避免在同一块石头上跌倒多次。</span></span><span data-type="background" style="background-color:rgb(255, 255, 255)"><span data-type="color" style="color:#F5222D">良好的规约有利于提高程序的可读性、可维护性、可复用性，切实提高软件产品质量。</span></span>
众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有靠右行驶条款，谁还敢上路。同理，对软件来说，<span data-type="color" style="color:#F5222D">开发规约绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，推行相对标准化，以一种普遍认可的方式一起做事</span>。
<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">    一、码出高效：标准统一，提升沟通效率和研发效能。</span></span>
<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  二、码出质量：防患未然，提升质量意识和系统可维护性，降低故障率。</span></span>
<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  三、码出情怀：工匠精神，追求极致的卓越精神，打磨精品代码。 </span></span>
## 一、编程规约
### 命名规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】类名使用UpperCamelCase风格，以下情形例外：DO / BO / DTO / VO / AO / UID等。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">MarcoPolo / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">marcoPolo / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】POJO类中的任何布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在本文MySQL规约中的建表约定第一条，表达是与否的值采用</span></span>`is_xxx`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的命名方式，所以，需要在&lt;resultMap&gt;设置从is_xxx到Xxx的映射关系。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">定义为</span></span>`Boolean isDeleted`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>的属性，它的方法也是`isDeleted()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，框架在反向解析的时候，“误以为”对应的属性名称是</span></span>`deleted`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，导致属性获取不到，进而抛出异常。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用</span></span>单数<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">形式，但是类名如果有复数含义，类名可以使用复数形式。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">应用工具类包名为com.alibaba.aone.force.util；类名为MessageUtils（此规则参考spring的框架结构）</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】杜绝完全不规范的缩写，集团认可的缩写请参考附2。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">&lt;某业务代码&gt;AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。</span></span>
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">接口方法签名：void commit();</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">     接口基础常量表示：String COMPANY = &quot;alibaba&quot;;</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">接口方法定义：</span></span>public abstract <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">void commit();</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【参考】各层命名规约： </span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">A) Service/DAO层方法命名规约</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   1） 获取单个对象的方法用get作前缀。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   2） 获取多个对象的方法用list作前缀，复数结尾，如：listObjects。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   3） 获取统计值的方法用count作前缀。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   4） 插入的方法用save/insert作前缀。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   5） 删除的方法用remove/delete作前缀。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   6） 修改的方法用update作前缀。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">B) 领域模型命名规约</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   1） 数据对象：xxxDO，xxx即为数据表名。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   3） 展示对象：xxxVO，xxx一般为网页名称。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">   4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</span></span>
### 常量定义：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">String key = </span></span>"Id#taobao\_"<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>+ tradeId；
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">    cache.put(key, value);</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  本例中同学A定义了缓存的key，然后缓存提取的同学B使用了Id#taobao来提取，少了下划线，导致故障。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Long a = 2l; 写的是数字的21，还是Long型的2?</span></span>
### 格式规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1） 左大括号前不换行。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2） 左大括号后换行。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3） 右大括号前换行。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 4） 右大括号后还有else等代码则不换行；表示终止右大括号后必须换行。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；而左大括号前需要加空格。详见第5条下方正例提示。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】if/for/while/switch/do等保留字与左右括号之间都必须加空格。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】任何二目、三目运算符的左右两边都必须加一个空格。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】采用4个空格缩进，禁止使用tab字符。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选：</span></span>`Use tab character`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">；而在eclipse中，必须勾选</span></span>`insert spaces for tabs`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>（涉及1-5点）
```
public static void main(String[] args) {
    // 缩进4个空格
    String say = "hello";
    // 运算符的左右必须有一个空格
    int flag = 0;
    // 关键词if与括号之间必须有一个空格，括号内f与左括号，0与右括号不需要空格
    if (flag == 0) {
        System.out.println(say);
    }

    // 左大括号前加空格且不换行；左大括号后换行
    if (flag == 1) {
        System.out.println("world");
    // 右大括号前换行，右大括号后有else，不用换行
    } else {
        System.out.println("ok");
    // 在右大括号后直接结束，则必须换行
    }
}
```
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】注释的双斜线与注释内容之间</span></span>有且仅有<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">一个空格。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】单行字符数不超过120个，超出则需要换行，换行时遵循如下原则：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1） 第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2） 运算符与下文一起换行。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3） 方法调用的点符号与下文一起换行。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 4） 方法调用中的多个参数需要换行时，在逗号后进行。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 5） 在括号前不要换行，见反例。</span></span>
8. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</span></span>
9. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】单个方法的总行数不超过80行。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80行。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。</span></span>
10. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">任何情形，没有必要插入</span></span>多个空行<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">进行隔开。</span></span>

### OOP规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用</span></span>类名<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">来访问即可。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">&quot;test&quot;.equals(object);</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">object.equals(&quot;test&quot;);</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">推荐使用java.util.Objects#equals （JDK7引入的工具类）</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】所有的相同类型的包装类对象之间</span></span>值的比较<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，全部使用equals方法比较。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】关于基本数据类型与包装数据类型的使用标准如下：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1） </span></span><span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:#FFFB8F">所有的POJO类属性必须使用包装数据类型。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2） RPC方法的返回值和参数必须使用包装数据类型。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3）</span></span><span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:#FFFB8F"> 所有的局部变量推荐使用基本数据类型。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><span data-type="color" style="color:#52C41A">正例</span>：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span><span data-type="color" style="color:#F5222D">反例</span>：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">某业务的交易报表上显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的HSF服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【</span></span><span data-type="background" style="background-color:rgb(255, 255, 255)"><span data-type="color" style="color:#1D39C4">强制</span></span><span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">】定义DO/DTO/VO等POJO类时，不要设定任何属性</span></span>默认值<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">某业务的DO的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</span></span>
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">注意serialVersionUID不一致会抛出序列化运行时异常。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</span></span>
8. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】POJO类必须写toString方法。使用工具类source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</span></span>
9. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】禁止在POJO类中，同时存在对应属性xxx的isXxx()和getXxx()方法。</span></span>
10. 【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。
    说明：
    
    ```
    String str = "a,b,c,,";
    String[] ary = str.split(",");
    // 预期大于3，结果是3
    System.out.println(ary.length);
    ```
11. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此规则优先于下一条。</span></span>
12. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。</span></span>
13. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】慎用Object的clone方法来拷贝对象。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现域对象的深度遍历式拷贝。</span></span>
### 集合处理：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】关于</span></span>`hashCode`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">和</span></span>`equals`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的处理，遵循如下规则：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1） 只要重写equals，就必须重写hashCode。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3） 如果自定义对象作为Map的键，那么必须重写hashCode和equals。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">参考</span></span>[hashCode 与 equals的辩证关系](http://www.atatech.org/articles/35549)<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>`String`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">正因为重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】使用Map的方法</span></span>`keySet()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">/</span></span>`values()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">/</span></span>`entrySet()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">返回集合对象时，不可以对其进行添加元素操作，否则会抛出UnsupportedOperationException异常。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】Collections类返回的对象，如：</span></span>`emptyList()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">/</span></span>`singletonList()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">等都是immutable list，不可对其进行添加或者删除元素的操作。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">某二方库的方法中，如果查询无结果，返回Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发UnsupportedOperationException异常。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;</span></span>
    说明： <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在subList场景中，</span></span>高度注意<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException 异常。</span></span>
    说明： <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">抽查表明，九成的开发同学对此知识点都有错误的认知。</span></span>
6. 【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。
    反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。
    正例：
    
    ```
    List<String> list = new ArrayList<>(2);
    list.add("guan");
    list.add("bao");
    
    String[] array = new String[list.size()];
    array = list.toArray(array);
    ```
    
    说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为list.size()被置为`null`，而此之后的数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行NPE判断。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在ArrayList#addAll方法的第一行代码即</span></span>`Object[] a = c.toArray();`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>其中c为输入集合参数，如果为null，则直接抛出异常。
8. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">String[] str = new String[] { &quot;a&quot;, &quot;b&quot; };</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">List</span></span> list = Arrays.asList(str);
    第一种情况：list.add("c"); 运行时异常。
    第二种情况：str[0]= "changed"; 那么list.get(0)也会随之修改，反之亦然。
9. 【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<? super T>不能使用get方法，两者在接口调用赋值的场景中易出错。
    说明：扩展说一下PECS (Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用<? extends T>。第二、经常往里插入的，适合用<? super T>。
10. 【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof判断，避免抛出ClassCastException异常。
    说明：毕竟泛型是在JDK5之后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。
    反例：
    
    ```
    List<String> generics = null;
    List notGenerics = new ArrayList(10);
    notGenerics.add(new Object());
    notGenerics.add(new Integer(1));
    
    generics = notGenerics;
    // 此处抛出ClassCastException异常
    String string = generics.get(0);
    ```
11. 【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。
    反例：
    
    ```
    List<String> list = new ArrayList<>();
    list.add("1");
    list.add("2");
    
    for (String item : list) {
        if ("1".equals(item)) {
            list.remove(item);
        }
    }
    ```
    
    说明：上述代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？
    参考：[ConcurrentModificationException异常分析 ](http://www.atatech.org/articles/47788)
    正例：
    
    ```
    Iterator<String> iterator = list.iterator();
    while (iterator.hasNext()) {
        String item = iterator.next();
        if (删除元素的条件) {
            iterator.remove();
        }
    }
    ```
12.【强制】在JDK7版本以上，Comparator要满足如下三个条件，不然Arrays.sort，Collections.sort会抛IllegalArgumentException异常。
说明：
 1） x，y的比较结果和y，x的比较结果相反。
 2） x>y，y>z，则x>z。
 3） x=y，则x，z比较结果和y，z比较结果相同。
反例：下例中没有处理相等的情况，实际使用中可能会出现异常：

```
new Comparator<Student>() {
    @Override
    public int compare(Student o1, Student o2) {
        return o1.getId() > o2.getId() ? 1 : -1;
    }
}
```

详细参考：[http://www.atatech.org/articles/59264](http://www.atatech.org/articles/59264)
13. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。</span></span>
14. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【</span></span>推荐】高度注意Map类集合K/V能不能存储null值的情况，如下表格：

| 集合类 | Key | Value | Super | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| Hashtable | <span data-type="color" style="color:#F5222D">不允许</span>为null | <span data-type="color" style="color:#F5222D">不允许</span>为null | Dictionary | 线程安全 |
| ConcurrentHashMap | <span data-type="color" style="color:#F5222D">不允许</span>为null | <span data-type="color" style="color:#F5222D">不允许</span>为null | AbstractMap | 锁分段技术（JDK8:CAS) |
| TreeMap | <span data-type="color" style="color:#F5222D">不允许</span>为null | <span data-type="color" style="color:#1D39C4">允许</span>为null | AbstractMap | 线程不安全 |
| HashMap | <span data-type="color" style="color:#1D39C4">允许</span>为null | <span data-type="color" style="color:#1D39C4">允许</span>为null | AbstractMap | 线程不安全 |

    反例：前期抽样表明近八成的同学认为ConcurrentHashMap是可以置入null值。在“[美杜莎](http://mcms-portal.alibaba-inc.com/?from=faq)”的批量翻译场景中，子线程分发时，出现置入null值的情况，但主线程没有捕获到此异常，导致排查困难。
15. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。</span></span>
16. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【参考】利用Set元素唯一的特性，可以快速对另一个集合进行去重操作，避免使用List的contains方法进行遍历去重操作。</span></span>

### 并发处理：

1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">资源驱动类、工具类、单例工厂类都需要注意。</span></span>
    反例：[单例模式引发商品无法加购阻断下单](https://www.atatech.org/articles/103225)
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">自定义线程工厂，并且根据外部特征进行分组，比如：来自同一机房的调用，把机房编号赋值给whatFeaturOfGroup</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Executors返回的线程池对象的弊端如下：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">1）</span></span>`FixedThreadPool`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">和</span></span>`SingleThreadPool`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">:</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">2）</span></span>`CachedThreadPool`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">和</span></span>`ScheduledThreadPool`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">:</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</span></span>
5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。
    正例：注意线程安全，使用DateUtils。亦推荐如下处理：
    
    ```
    private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd");
        }
    };
    ```
    
    说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。
6. 【强制】必须回收自定义的`ThreadLocal`变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 `ThreadLocal`变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收。
    正例：
    
    ```
    objectThreadLocal.set(someObject);
    try {
        ...
    } finally {
        objectThreadLocal.remove();
    }
    ```
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</span></span>
8. 【强制】在try代码块之前调用Lock实现类的lock()方法，避免由于加锁失败，导致finally调用unlock()抛出异常。
    说明：在lock方法中可能抛出uncheck异常，如果放在try代码块中，必然触发finally中的unlock方法的执行，它会调用AQS的tryRelease方法（取决于具体实现类）。根据Lock接口中的unlock描述，对未加锁的对象解锁抛出unchecked异常，如：IllegalMonitorStateException，虽然都是加锁失败造成程序中断，但是真正加锁出错信息可能被后者覆盖。
    反例：
    
    ```
    Lock lock = new XxxLock();
    preDo();
    try {
            // 无论加锁是否成功，unlock都会执行
        lock.lock();
        doSomething();
    } finally {
        lock.unlock();
    }
    ```
9. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">阿里云平台产品技术部，域名更新具体产品信息保存到tair，Timer产生了RunTimeExcetion异常后，定时任务不再执行，通过检查日志发现原因，改为ScheduledExecutorService方式。</span></span>
10. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】资金相关的金融敏感信息，使用悲观锁策略。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</span></span>
11. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">注意，子线程抛出异常堆栈，不能在主线程try-catch到。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在“马可波罗平台”的翻译同步转异步多线程时，由于翻译过程抛出异常，导致countDown方法失败，经常超时才返回。</span></span>
12. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【参考】ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题。</span></span>

### 控制语句:
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在高并发场景中，避免使用“等于”判断作为中断或退出的条件。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">某营销活动发奖，判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，活动无法终止，产生资损。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】避免采用取反逻辑运算符。</span></span>

### 注释规约:
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】类、类属性、类方法的注释必须使用javadoc规范，使用/**内容*/格式，不得使用//xxx方式。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在IDE编辑窗口中，javadoc方式会提示相关注释，生成javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。</span></span>

### 其它：
1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。
    说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】避免用Apache Beanutils进行属性的copy。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">Apache BeanUtils性能较差，可以使用其他方案比如Spring BeanUtils, Cglib BeanCopier，注意均是浅拷贝。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是new Date().getTime();</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果想获取更加精确的纳秒级时间值，使用System.nanoTime的方式。在JDK8中，针对统计时间等场景，推荐使用Instant类。</span></span>
4. 【强制】日期格式化时，传入pattern中表示年份统一使用小写的`y`。
    说明：日期格式化时，`yyyy`表示当天所在的年，而大写的`YYYY`代表是`week in which year`（JDK7之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的`YYYY`就是下一年。另外需要注意：
    
    * 表示月份是大写的`M`；
    * 表示分钟则是小写的`m`；
    * 24小时制的是大写的`H`；
    * 12小时制的则是小写的`h`。
        正例：表示日期和时间的格式如下所示：
        ` new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); `
        反例：某业务因使用YYYY/MM/dd进行日期格式化，2017/12/31执行结果为2018/12/31，导致P4P广告在2017年12月31日当日实时消耗跌0，造成P2故障，参考：[记一次日期格式化引起的P2故障](https://www.atatech.org/articles/97733)

---

## 二、异常日志
### 异常处理:
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】不要在finally块中使用return。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">finally块中的return返回后方法结束执行，不会再执行try块中的return语句。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  </span></span>反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">public int f(){ return Integer对象}，如果为null，自动解箱抛NPE。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2） 数据库的查询结果可能为null。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 4） 远程调用返回对象时，一律要求空指针判断，防止NPE。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 5） 对于session中获取的数据，建议进行NPE检查，避免空指针。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 6） 级联调用obj.getA().getB().getC()；易产生NPE。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">  </span></span>反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">“一拍档客户”的返回值从空对象变成了null，导致线上故障，NPE无小事。</span></span>
### 日志规约:
1. 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架（SLF4J、JCL--Jakarta Commons Logging）中的API。什么是日志框架和日志系统，请参考webx作者[宝宝的文章](http://openwebx.org/docs/Webx3_Guide_Book.html#d0e14854)，文章里也详细说明了为什么不能直接依赖使用日志系统而是日志框架，以及应用的pom中如何做dependencyManagement。
    说明：日志框架（SLF4J、JCL--Jakarta Commons Logging）的使用方式（推荐使用SLF4J）：
    使用SLF4J：
    
    ```
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    private static final Logger logger = LoggerFactory.getLogger(Abc.class);
    ```
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以“应用名.log”来保存，保存在</span></span>/home/admin/应用名/logs/<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">目录下，过往日志格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">以mppserver应用为例，日志保存在/home/admin/mppserver/logs/mppserver.log，历史日志名称为mppserver.log.2016-08-01</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/monitor/visit等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">mppserver应用中单独监控时区转换异常，如：mppserver_monitor_timeZoneConvert.log</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</span></span>
4. 【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。
    说明：logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。
    正例：（条件）建议优先采用
    
    ```
    if (logger.isDebugEnabled()) { 
        logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 
    }
    ```
    
    正例：（占位符）
    
    ```
    logger.debug("Processing trade with id: {} and symbol: {}", id, symbol);
    ```
5. 【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。
    正例：
    
    ```
    <logger name="com.taobao.ecrm.member.config" additivity="false">
    ```
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】生产环境禁止直接使用System.out 或System.err 输出日志或使用e.printStackTrace()打印异常堆栈。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">标准日志输出与标准错误输出文件每次Jboss重启时才滚动，如果大量输出送往这两个文件，容易造成文件大小超过操作系统大小限制。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上抛。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e);</span></span>

---

## MySQL规约
### 建表规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否），此规则同样适用于odps建表。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">任何字段如果为非负数，必须是unsigned。</span></span>
    注意：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在&lt;resultMap&gt;设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">表达逻辑删除的字段名</span></span>`is_deleted`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，1表示删除，0表示未删除。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】主键索引应以pk_开头，唯一索引要以uk_开头，普通索引要以idx_开头。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">pk_即primary key；uk_ 即unique key；idx_即index的简称。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】新增列必须在已有字段后面。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">OB默认新增列加在后面。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】表名、字段名必须使用小写字母或数字，字段命名可参考附2；禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">getter_admin，task_config，level3_name</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">GetterAdmin，taskConfig，level_3_name</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】表名不使用复数名词。</span></span>
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】禁用保留字，如desc、range、match、delayed等，</span></span>[参考官方保留字](http://dev.mysql.com/doc/refman/5.7/en/keywords.html)
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】小数类型为decimal，禁止使用float和double。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。</span></span>
8. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】如果存储的字符串长度几乎相等，使用CHAR定长字符串类型。</span></span>
9. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</span></span>
10. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】表必备三字段：id, gmt_create, gmt_modified。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">其中id必为主键，类型为bigint unsigned、单表时自增、步长为1；分表时改为从TDDL Sequence取值，确保分表之间的全局唯一。gmt_create, gmt_modified的类型均为date_time类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。</span></span>
11. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1）不是频繁修改的字段。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2）不是varchar超长字段，更不能是text字段。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">各业务线经常冗余存储商品名称，避免查询时需要调用IC服务获取。</span></span>
12. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">某业务三年总数据量才2万行，却分成1024张表，问：你为什么这么设计？答：分1024张表，不是标配吗？</span></span>
### 索引规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">即使双表join也要注意表索引、SQL性能。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">索引文件具有B-Tree的</span></span><span data-type="background" style="background-color:rgb(255, 255, 255)"><span data-type="color" style="color:#F5222D">最左前缀匹配特性</span></span><span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，如果左边的值未确定，那么无法使用此索引。</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】如果有order by的场景，请注意利用索引的</span></span>有序性<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">where a=? and b=? order by c; 索引：a_b_c</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b无法排序。</span></span>
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】利用延迟关联或者子查询优化超多分页场景。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">先快速定位需要获取的id段，然后再关联：</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">“服务市场”某交易分页超过1000页，用户点击最后一页时，数据库基本处于半瘫痪状态。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是const最好。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1）const 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2）ref 指的是使用普通的索引。（normal index）</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3）range 对索引进行范围检索。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</span></span>
### SQL规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】不要使用count(列名)或count(常量)来替代count(*)，count(*)就是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】count(distinct col) 计算该列除NULL之外的不重复数量。注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。</span></span>
    正例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】使用</span></span>`ISNULL()`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">来判断是否为</span></span>`NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">值。</span></span>
    说明：`NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">与任何值的直接比较都为</span></span>`NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 1） </span></span>`NULL<>NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的返回结果是</span></span>`NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，而不是</span></span>`false`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 2） </span></span>`NULL=NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的返回结果是</span></span>`NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，而不是</span></span>`true`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> 3） </span></span>`NULL<>1`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">的返回结果是</span></span>`NULL`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，而不是</span></span>`true`<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。</span></span>
5. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。</span></span>
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">（概念解释）学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</span></span>
8. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】IDB数据订正（特别是删除或修改记录操作）时，要先select，避免出现误删除，确认无误才能提交执行。</span></span>
9. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【参考】因集团国际化需要，所有的字符存储与表示，均以utf-8编码，那么字符计数方法注意：</span></span>
    说明：
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">SELECT LENGTH(&quot;阿里巴巴&quot;)； 返回为12</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">SELECT CHARACTER_LENGTH(&quot;阿里巴巴&quot;)； 返回为4</span></span>
    <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码的区别。</span></span>
10. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</span></span>
### ORM规约：
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。3）多余字段增加网络消耗，尤其是 text 类型的字段。</span></span>
    反例：[B类电商中台交易下跌的故障案例](http://www.atatech.org/articles/71418)<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">　　</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">参见定义POJO类以及数据库字段定义规定，在sql.xml增加映射，是必须的。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义</span></span>；反过来，每一个表也必然有一个与之对应。
    说明：配置映射关系，使字段与DO类解耦，方便维护。
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】sql.xml配置中参数注意：</span></span><span data-type="background" style="background-color:rgb(255, 255, 255)"><span data-type="color" style="color:#F5222D">#{}，#param# 不要使用${} </span></span><span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">此种方式容易出现SQL注入。</span></span>
5. 【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。
    说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合，线上因为这个原因曾经出现过OOM。
    正例：在sqlmap.xml中引入 #start#, #size#
    
    Map<String, Object> map = new HashMap<>();
    map.put("start", start);
    map.put("size", size);
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】不允许直接拿HashMap与HashTable作为查询结果集的输出。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">某同学为避免写一个&lt;resultMap&gt;，直接使用HashTable来接收数据库返回结果，结果出现日常是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。</span></span>
7. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。</span></span>


---

## 其他
1. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】在datetime类型后面增加时间间隔，不能直接加整数。加整数的行为是不确定的，要用date_add(gmt_own, interval own_second second) &lt; now()这种方式去写。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">内部处理整数时间相加，存在进制溢出的问题，行为不确定，因此建议使用换算后的秒数进行时间的更新。</span></span>
2. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】任何操作，都是先保存数据库成功后，再进行缓存的新增、更新、清除操作。</span></span>
3. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】调用远程操作必须有超时设置。类似于HttpClient的超时设置需要自己明确去设置Timeout。</span></span>
    反例：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">根据经验表明，无次数的故障都是因为没有设置超时。</span></span>
4. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】 [MsgBroker] 消息投递不保证不重复，所以消息接收端需要控制幂等。</span></span>
5. 【强制】用户请求传入的任何参数必须做有效性验证。
    说明：忽略参数校验可能导致：
    
    * page size过大导致内存溢出
    * 恶意order by导致数据库慢查询
    * 缓存击穿
    * [SSRF](http://docs.alibaba-inc.com/pages/viewpage.action?pageId=352879424)
    * 任意重定向
    * SQL注入
    * Shell注入
    * [反序列化注入](http://www.freebuf.com/vuls/90840.html)
        
    * 正则输入源串拒绝服务ReDOS
        说明：Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的效果，参考： [ReDoS攻击简单分析](http://www.atatech.org/articles/23798)
6. <span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。</span></span>
    说明：<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">WebX请参考：</span></span>[Fasttext 安全宏使用说明](http://www.atatech.org/articles/45545)<span data-type="color" style="color:rgb(36, 41, 46)"><span data-type="background" style="background-color:rgb(255, 255, 255)">。SpringMVC请参考：</span></span>[Security-light 使用说明](http://gitlab.alibaba-inc.com/ali_security_public/stc-wiki/wikis/Light-Security-Package-CN)

